import numpy as np
from matplotlib import pyplot as plt


# =============================================================================

# Класс для решения алгебраических систем методом Томаса (TDMA)
# =============================================================================
class AlgebraicSolver:
    """
    Класс для решения алгебраических систем с трёхдиагональной матрицей (метод Томаса).
    """

    def tdma(self, matrix: np.ndarray, f: np.ndarray) -> np.ndarray:
        """
        Решает трёхдиагональную систему уравнений методом Томаса.

        Параметры:
        -----------
        matrix : np.ndarray
            Коэффициентная матрица системы.
        f : np.ndarray
            Вектор правых частей.

        Возвращает:
        --------
        np.ndarray
            Решение системы.
        """
        n = len(f)
        # Извлекаем элементы ниже, по диагонали и выше главной диагонали
        a = [0] + [matrix[i][i - 1] for i in range(1, n)]
        b = [matrix[i][i] for i in range(n)]
        c = [matrix[i][i + 1] for i in range(n - 1)] + [0]
        f = list(map(float, f))

        alpha = [-c[0] / b[0]]
        beta = [f[0] / b[0]]
        x = np.zeros(n)

        for i in range(1, n):
            denom = a[i] * alpha[i - 1] + b[i]
            alpha.append(-c[i] / denom)
            beta.append((f[i] - a[i] * beta[i - 1]) / denom)

        x[n - 1] = beta[n - 1]
        for i in range(n - 1, 0, -1):
            x[i - 1] = alpha[i - 1] * x[i] + beta[i - 1]

        return x


# =============================================================================

# Функции для задания исходных и граничных условий
# =============================================================================
def phi(x, t):
    """
    Функция источника в уравнении теплопроводности.
    Здесь: φ(x,t) = 0
    """
    return 0


def psi(x):
    """
    Начальное условие: ψ(x) = 0
    """
    return 0


def gamma_0(t):
    """
    Граничное условие в точке x=0: γ0(t) = -t(t² + 1)
    """
    return -t * (t ** 2 + 1)


def gamma_1(t):
    """
    Граничное условие в точке x=l: γ1(t) = t²
    """
    return t ** 2


# =============================================================================

# Явная схема
# =============================================================================
def explicit_scheme(a, M, N, l, T):
    """
    Решает уравнение теплопроводности методом явной схемы.

    Параметры:
    -----------
    a       : float
              Коэффициент диффузии.
    M       : int
              Количество разбиений по пространству (узлов будет M+1).
    N       : int
              Количество временных шагов (слоёв будет N+1).
    l       : float
              Длина пространственного отрезка.
    T       : float
              Общее время моделирования.

    Возвращает:
    --------
    tuple: (x, t, u)
        x : массив координат по x,
        t : массив моментов времени,
        u : двумерный массив решения u(t,x)
    """
    h = l / M
    tau = T / N
    lambda_ = (a ** 2 * tau) / (h ** 2)
    if lambda_ > 0.5:
        print(f"Предупреждение: lambda = {lambda_:.3f} > 0.5, схема может быть неустойчивой!")

    x = np.linspace(0, l, M + 1)
    t = np.linspace(0, T, N + 1)
    u = np.zeros((N + 1, M + 1))

    # Начальное условие
    for m in range(M + 1):
        u[0, m] = psi(x[m])

    # Граничные условия для всех временных слоёв
    for n in range(N + 1):
        u[n, 0] = gamma_0(t[n])
        u[n, M] = gamma_1(t[n])

    # Явная схема
    for n in range(N):
        for m in range(1, M):
            u[n + 1, m] = (u[n, m] +
                           lambda_ * (u[n, m + 1] - 2 * u[n, m] + u[n, m - 1])
                           + tau * phi(x[m], t[n]))
    return x, t, u


# =============================================================================

# Неявная схема с использованием метода прогонки (TDMA)
# =============================================================================
def implicit_scheme(a, M, N, l, T):
    """
    Решает уравнение теплопроводности методом неявной схемы.

    Параметры:
    -----------
    a       : float
              Коэффициент диффузии.
    M       : int
              Количество разбиений по пространству (узлов будет M+1).
    N       : int
              Количество временных шагов (слоёв будет N+1).
    l       : float
              Длина пространственного отрезка.
    T       : float
              Общее время моделирования.

    Возвращает:
    --------
    tuple: (x, t, u)
        x : массив координат по x,
        t : массив моментов времени,
        u : двумерный массив решения u(t,x)
    """
    h = l / M
    tau = T / N
    lambda_ = (a ** 2 * tau) / (h ** 2)

    x = np.linspace(0, l, M + 1)
    t = np.linspace(0, T, N + 1)
    u = np.zeros((N + 1, M + 1))

    # Начальное условие
    for m in range(M + 1):
        u[0, m] = psi(x[m])

    # Граничные условия для всех временных слоёв
    for n in range(N + 1):
        u[n, 0] = gamma_0(t[n])
        u[n, M] = gamma_1(t[n])

    # Формирование коэффициентов для трёхдиагональной системы
    A = -lambda_ * np.ones(M - 1)  # поддиагональ
    B = (1 + 2 * lambda_) * np.ones(M - 1)  # главная диагональ
    C = -lambda_ * np.ones(M - 1)  # наддиагональ

    for n in range(N):
        d = u[n, 1:M] + tau * phi(x[1:M], t[n])
        d[0] += lambda_ * gamma_0(t[n + 1])
        d[-1] += lambda_ * gamma_1(t[n + 1])
        u[n + 1, 1:M] = initiate_tdma(A, B, C, d)
    return x, t, u


# =============================================================================

# Функция-обёртка для вызова метода Томаса
# =============================================================================
def initiate_tdma(A, B, C, d):
    """
    Обёртка для решения трёхдиагональной системы с помощью метода Томаса.

    Параметры:
    -----------
    A : array_like
        Поддиагональные элементы.
    B : array_like
        Главная диагональ.
    C : array_like
        Наддиагональные элементы.
    d : array_like
        Вектор правых частей.

    Возвращает:
    --------
    np.ndarray
        Решение системы.
    """
    solver = AlgebraicSolver()
    n = len(B)
    matrix = np.zeros((n, n))
    np.fill_diagonal(matrix, B)
    np.fill_diagonal(matrix[1:], A)
    np.fill_diagonal(matrix[:, 1:], C)
    return solver.tdma(matrix, d)


# =============================================================================

# Функция для построения графика решения
# =============================================================================
def plot_solution(x, t, u, title):
    """
    Строит контурный график решения уравнения теплопроводности.

    Параметры:
    -----------
    x : array_like
        Массив координат по x.
    t : array_like
        Массив моментов времени.
    u : array_like
        Двумерный массив решения u(t,x).
    title : str
        Заголовок графика.
    """
    X, T = np.meshgrid(x, t)
    plt.figure(figsize=(8, 6))
    cp = plt.contourf(X, T, u, 20, cmap="hot")
    plt.colorbar(cp, label="u(x,t)")
    plt.xlabel("x")
    plt.ylabel("t")
    plt.title(title)
    plt.show()


# =============================================================================

# Основная функция
# =============================================================================
def main():
    # Параметры задачи
    a = 1.0  # Коэффициент диффузии
    M = 50  # Количество разбиений по пространству (узлов будет M+1)
    N = 6  # Количество временных шагов (слоёв будет N+1)
    l = 1.0  # Длина пространственного отрезка
    T = 1.0  # Общее время моделирования

    # Решение явной схемой
    x_exp, t_exp, u_explicit = explicit_scheme(a, M, N, l, T)
    plot_solution(x_exp, t_exp, u_explicit, "Решение уравнения теплопроводности (Явная схема)")

    # Решение неявной схемой
    x_imp, t_imp, u_implicit = implicit_scheme(a, M, N, l, T)
    plot_solution(x_imp, t_imp, u_implicit, "Решение уравнения теплопроводности (Неявная схема)")

    # Вывод таблицы с результатами в консоль
    print("\nРезультаты явного метода:")
    print("x\t\tu(x, T)")
    for m in range(M + 1):
        print(f"{x_exp[m]:.4f}\t{u_explicit[-1, m]:.6f}")

    print("\nРезультаты неявного метода:")
    print("x\t\tu(x, T)")
    for m in range(M + 1):
        print(f"{x_imp[m]:.4f}\t{u_implicit[-1, m]:.6f}")


if __name__ == "__main__":
    main()