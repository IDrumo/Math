import numpy as np


# Простая итерация для поиска собственных значений
def power_iteration(A, x0, eps=1e-10, max_iter=100):
    """
    Реализует метод простой итерации (метод степеней) для нахождения
    наибольшего по модулю собственного значения и соответствующего
    собственного вектора матрицы A.

    Args:
      A: Матрица, для которой нужно найти собственное значение.
      x0: Начальное приближение собственного вектора.
      eps: Допустимая погрешность для остановки итераций.
      max_iter: Максимальное число итераций.

    Returns:
      Кортеж из двух элементов: (собственное значение, собственный вектор).
    """

    global l, step
    x = x0
    for i in range(max_iter):
        step = i
        # y = Ax
        y = np.dot(A, x)
        # lambda = y.T @ x
        l = np.dot(y.transpose(), x)
        # x = y / ||y||
        x = y / np.linalg.norm(y)

        # Проверяем критерий остановки
        if np.linalg.norm(x - x0) < eps:
            return l, x, step
        x0 = x

    print("Превышено максимальное число итераций.")
    return l, x, step


def main():
    matrices = {
        "Матрица 1": (np.array([[-0.168700, 0.353699, 0.008540, 0.733624],
                                [0.353699, 0.056519, -0.723182, -0.076440],
                                [0.008540, -0.723182, 0.015938, 0.342333],
                                [0.733624, -0.076440, 0.342333, -0.045744]]),
                      np.array([-0.943568, -0.744036, 0.687843, 0.857774])),
        "Матрица 2": (np.array([[2.2, 1, 0.5, 2],
                                [1, 1.3, 2, 1],
                                [0.5, 2, 0.5, 1.6],
                                [2, 1, 1.6, 2]]),
                      np.array([5.652, 1.545, -1.420, 0.2226])),
        "Матрица 3": (np.array([[1.00, 0.42, 0.54, 0.66],
                                [0.42, 1.00, 0.32, 0.44],
                                [0.54, 0.32, 1.00, 0.22],
                                [0.66, 0.44, 0.22, 1.00]]),
                      np.array([2.3227, 0.7967, 0.6383, 0.2423])),
        "Проверяющая матрица": (np.array(
            [[2.00, 1.00],
             [1.00, 2.00]]),
                                np.array([4, 5])),
        "Матрица методички": (np.array(
            [[2, 1, 1],
             [1, 2.5, 1],
             [1, 1, 3]
             ]),

                              np.array([1.185089, 4.555030, 1.759839])),
    }

    for name, (A, expected_eigenvalues) in matrices.items():
        print(f"-------------{name}-------------")

        x0 = np.array([1 for i in range(expected_eigenvalues.size)])

        eigenval, vector, iterations = power_iteration(A, x0)

        residual_matrix = A - eigenval * np.eye(A.shape[0])
        det = np.linalg.det(residual_matrix)

        # Выводим результаты
        print("Истинные собственные значения:", np.sort(np.linalg.eigvals(A)))
        print("Найденное собственное значение: ", eigenval)
        print("Найденный собственный вектор: ", vector)
        print("Количество итераций: ", iterations)
        print("Определитель матрицы |A - λI| (должен быть близок к нулю):", det)
        print()


if __name__ == '__main__':
    main()
